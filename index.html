<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Imagi-world (Da Vinci Architect)</title>
    <style>
        :root {
            --bg: #050505;
            --panel: #1a1a1a;
            --input: #333;
            --accent: #00ff9d;
            --highlight: #00ff9d;
            --text: #e0e0e0;
            --success: #2ecc71;
            --danger: #ff3b30;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Courier New', Courier, monospace; /* Monospace for strict logic feel */
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        h1 { 
            margin: 20px 0; 
            font-size: 1.6rem; 
            text-align: center; 
            letter-spacing: -1px; 
            text-transform: uppercase; 
            color: var(--accent);
        }

        .container { max-width: 800px; width: 100%; z-index: 1; }

        .controls {
            background: var(--panel);
            padding: 20px;
            border-radius: 0;
            margin-bottom: 20px;
            border: 1px solid #333;
        }

        .control-group { margin-bottom: 20px; }
        label { display: flex; justify-content: space-between; margin-bottom: 8px; font-weight: 700; font-size: 0.8rem; color: #888; text-transform: uppercase; }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent);
            height: 2px;
            background: #333;
            appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 20px; height: 20px; background: var(--accent); border-radius: 0; cursor: pointer;
        }

        input[type="number"] {
            background: #111; border: 1px solid #333; color: var(--accent); padding: 10px; font-family: inherit; width: 100%; font-size: 1.1rem;
        }

        .button-group { display: flex; gap: 10px; margin-top: 30px; }

        button {
            background: transparent;
            color: var(--accent);
            border: 1px solid var(--accent);
            padding: 15px;
            font-size: 1rem;
            font-family: inherit;
            font-weight: 700;
            cursor: pointer;
            flex: 1;
            text-transform: uppercase;
            transition: all 0.1s;
        }
        button:hover:not(:disabled) { background: var(--accent); color: var(--bg); }
        button:disabled { border-color: #333; color: #555; cursor: not-allowed; }
        
        button.danger { border-color: var(--danger); color: var(--danger); }
        button.danger:hover:not(:disabled) { background: var(--danger); color: white; }

        .game-area {
            background: var(--panel);
            padding: 40px 20px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #333;
            position: relative;
        }

        /* 
           STRICT SYNC DISPLAY
           Opacity is managed explicitly by JS events.
           No CSS transition delay.
        */
        .premise-display {
            font-size: 1.6rem;
            color: #fff;
            margin: 20px 0;
            line-height: 1.5;
            font-weight: 700;
            min-height: 80px;
            max-width: 95%;
            opacity: 0; 
            will-change: opacity;
        }

        .status { position: absolute; top: 10px; left: 10px; font-size: 0.6rem; color: #555; text-transform: uppercase; }

        .feedback { 
            height: 30px; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: 1.2rem; 
            font-weight: 900; 
            text-transform: uppercase; 
            letter-spacing: 2px;
        }
        .feedback.correct { color: var(--success); }
        .feedback.incorrect { color: var(--danger); }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px;
            background: #333;
            margin-top: 20px;
            border: 1px solid #333;
        }
        .stat-box { background: var(--panel); padding: 15px; text-align: center; }
        .stat-val { font-size: 1.4rem; font-weight: 700; color: var(--text); }
        .stat-lbl { font-size: 0.6rem; color: #666; letter-spacing: 1px; text-transform: uppercase; margin-bottom: 5px; }

        #runtime-diagnostics-panel {
            margin-top: 15px;
            font-size: 0.7rem;
            color: #444;
            border-top: 1px solid #222;
            padding-top: 10px;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>

<main class="container">
    <h1>Imagi-world <span style="font-size:0.5em; vertical-align: middle;">(DA VINCI)</span></h1>

    <div class="controls">
        <div class="control-group">
            <label>N-Back Level <span id="n-value" style="color:var(--accent)">1</span></label>
            <input type="range" id="n-slider" min="1" max="12" value="1">
        </div>

        <div class="control-group">
            <label>Chain Length (k) <span id="k-value" style="color:var(--accent)">1</span></label>
            <input type="range" id="k-slider" min="1" max="8" value="1">
        </div>

        <div class="control-group">
            <label>Interval (Seconds) <span id="spt-value" style="color:var(--accent)">4.0</span>s</label>
            <input type="range" id="spt-slider" min="1.5" max="20" step="0.5" value="4.0">
        </div>
        
        <div class="control-group">
             <label>Total Trials</label>
             <input type="number" id="numTrialsInput" value="20" min="5" max="1000">
        </div>

        <div class="button-group">
            <button id="start-btn">START SESSION</button>
            <button id="stop-btn" class="danger" disabled>STOP</button>
        </div>

        <div id="runtime-diagnostics-panel">
            <span id="diag-status">READY</span>
            <span id="diag-meta">iPhone: Unmute & Volume Up</span>
        </div>
    </div>

    <div class="game-area">
        <div class="status" id="status">IDLE</div>
        <div class="premise-display" id="premise-display">System Ready</div>
        <div class="feedback" id="feedback"></div>

        <div class="response-buttons" style="margin-top:20px; display:flex; gap:20px; opacity: 0.5;">
            <button id="match-btn" disabled>MATCH</button>
            <button id="no-match-btn" disabled>NO MATCH</button>
        </div>
    </div>

    <div class="stats">
        <div class="stat-box">
            <div class="stat-lbl">Trial</div>
            <div class="stat-val" id="trial-count">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-lbl">Score</div>
            <div class="stat-val" id="score">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-lbl">Accuracy</div>
            <div class="stat-val" id="accuracy">-</div>
        </div>
    </div>
</main>

<script>
/**
 * IMAGI-WORLD CORE v7.0 (Da Vinci Architect)
 * 
 * 1. LOGIC: Strict Geometric Inversion. NO REPLICATION.
 * 2. VARIETY: High Entropy Generator (Always fresh letters for non-matches).
 * 3. SYNC: Visuals trigger on hardware audio start.
 */

const RELATIONS = {
    'N': 'North', 'S': 'South', 'E': 'East', 'W': 'West',
    'NE': 'North-East', 'NW': 'North-West', 'SE': 'South-East', 'SW': 'South-West'
};
const AXES = Object.keys(RELATIONS);

class RNG {
    constructor() { this.seed = Date.now(); }
    next() {
        let t = (this.seed += 0x6D2B79F5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
    choice(arr) { return arr[Math.floor(this.next() * arr.length)]; }
    shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(this.next() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }
}

class Atom {
    constructor(axis, head, tail) {
        this.axis = axis; this.head = head; this.tail = tail;
    }
    toString() { return `${this.head} is ${RELATIONS[this.axis]} of ${this.tail}`; }
}

class Premise {
    constructor(atoms) { this.atoms = atoms; }
    toString() { return this.atoms.map(a => a.toString()).join('; and '); }
}

class DaVinciGenerator {
    constructor(rng) {
        this.rng = rng;
        this.letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
    }

    getOpposite(axis) {
        const map = { 'N':'S', 'S':'N', 'E':'W', 'W':'E', 'NE':'SW', 'SW':'NE', 'NW':'SE', 'SE':'NW' };
        return map[axis];
    }

    /**
     * Gets a FRESH pool of letters.
     * Explicitly avoids checking history to ensure variety and prevent 
     * "cognitive ease" from repetitive symbols.
     */
    getFreshPool(count) {
        const pool = [...this.letters];
        return this.rng.shuffle(pool).slice(0, count);
    }

    generate(k, matchTarget = null) {
        if (matchTarget) return this.buildInvertedMatch(matchTarget);
        return this.buildFresh(k);
    }

    /**
     * Builds a COMPLETELY NEW premise.
     * Ensures variety by using the full alphabet every time.
     */
    buildFresh(k) {
        const pool = this.getFreshPool(k + 1);
        const atoms = [];
        for (let i = 0; i < k; i++) {
            const head = pool[i];
            const tail = pool[i+1];
            const axis = this.rng.choice(AXES);
            atoms.push(new Atom(axis, head, tail));
        }
        return new Premise(atoms);
    }

    /**
     * STRICT GEOMETRIC INVERSION.
     * 1. Reverse the atom order (Path Reversal).
     * 2. Swap Head/Tail (Node Inversion).
     * 3. Invert Axis (Vector Inversion).
     * This guarantees NO replication.
     */
    buildInvertedMatch(target) {
        const atoms = [];
        // Iterate backwards through the target chain
        for (let i = target.atoms.length - 1; i >= 0; i--) {
            const original = target.atoms[i];
            const newAxis = this.getOpposite(original.axis);
            // Swap Tail/Head + Invert Axis
            atoms.push(new Atom(newAxis, original.tail, original.head));
        }
        return new Premise(atoms);
    }

    /**
     * Lure Logic:
     * If we want a distractor (rare), we reuse letters but break logic.
     * But per your request for variety, this is used sparingly.
     */
    buildLure(target) {
        const atoms = target.atoms.map(a => {
            const r = this.rng.next();
            if (r < 0.5) return new Atom(this.rng.choice(AXES.filter(x => x !== a.axis)), a.head, a.tail); // Wrong Axis
            return new Atom(a.axis, a.tail, a.head); // Wrong Node Order
        });
        return new Premise(atoms);
    }
}

class GameEngine {
    constructor() {
        this.rng = new RNG();
        this.gen = new DaVinciGenerator(this.rng);
        this.history = [];
        this.n = 1;
        this.k = 1;
        this.spt = 4.0;
        this.running = false;
        this.abortCtrl = null;
        this.score = 0;
        this.synth = window.speechSynthesis;
    }

    /**
     * CRITICAL SYNC FUNCTION
     * 1. Hide Visuals.
     * 2. Start Audio.
     * 3. Show Visuals ONLY when 'onstart' fires.
     */
    speakSynced(text) {
        const display = document.getElementById('premise-display');
        
        // 1. Hide Immediately
        display.style.transition = 'none';
        display.style.opacity = '0';
        display.innerText = text;
        
        this.synth.cancel();
        
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 1.15;
        u.pitch = 1.0;
        u.volume = 1.0;

        // iOS Voice Fallback
        const voices = this.synth.getVoices();
        const preferred = voices.find(v => v.name.includes('Samantha')) || voices.find(v => v.lang.startsWith('en'));
        if(preferred) u.voice = preferred;

        // 3. Reveal on Hardware Start
        u.onstart = () => {
            display.style.transition = 'opacity 0.1s ease-out';
            display.style.opacity = '1';
        };

        this.synth.speak(u);
    }

    speakPlain(text) {
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 1.15;
        u.volume = 1.0;
        this.synth.speak(u);
    }

    async vocalCountdown() {
        const display = document.getElementById('premise-display');
        display.style.opacity = '1';
        display.style.color = 'var(--highlight)';
        display.style.fontSize = "3rem";

        const nums = ["3", "2", "1"];
        for (let n of nums) {
            display.innerText = n;
            this.speakPlain(n === "3" ? "Three" : n === "2" ? "Two" : "One");
            await new Promise(r => setTimeout(r, 1000));
        }

        display.style.opacity = '0';
        await new Promise(r => setTimeout(r, 100));
        display.innerText = "";
        display.style.fontSize = "";
        display.style.color = "#fff";
    }

    async runSession(totalTrials) {
        this.running = true;
        this.abortCtrl = new AbortController();
        this.history = [];
        this.score = 0;
        
        document.getElementById('start-btn').disabled = true;
        document.getElementById('stop-btn').disabled = false;
        document.getElementById('score').innerText = "0";
        document.getElementById('accuracy').innerText = "-";

        try {
            // Engine Warmup
            await this.vocalCountdown();

            document.getElementById('status').innerText = "RUNNING";

            for (let i = 0; i < totalTrials; i++) {
                if (this.abortCtrl.signal.aborted) break;
                
                const trialStart = Date.now();
                
                // --- LOGIC CORE ---
                // ~35% Match Rate
                let isMatch = (i >= this.n) && (this.rng.next() > 0.65);
                const target = isMatch ? this.history[i - this.n] : null;
                let premise;
                let debugType = "";

                if (isMatch) {
                    // MUST BE INVERTED MATCH
                    premise = this.gen.generate(this.k, target);
                    debugType = "MATCH (INVERTED)";
                } else {
                    // NON-MATCH
                    // 80% Fresh (Variety), 20% Lure (Conflict)
                    if (i >= this.n && this.rng.next() > 0.8) {
                        premise = this.gen.buildLure(this.history[i - this.n]);
                        debugType = "NO MATCH (LURE)";
                    } else {
                        premise = this.gen.buildFresh(this.k);
                        debugType = "NO MATCH (NEW)";
                    }
                }
                
                this.history.push(premise);
                
                // --- UI ---
                document.getElementById('trial-count').innerText = i + 1;
                document.getElementById('diag-status').innerText = `T${i+1}: ${debugType}`;
                document.getElementById('feedback').innerText = "";

                // --- SYNCED EXECUTION ---
                this.speakSynced(premise.toString());
                
                // --- INPUT ---
                const action = await this.waitForInput(this.spt * 1000, this.abortCtrl.signal);
                
                // --- SCORING ---
                if (!this.abortCtrl.signal.aborted) {
                    let correct = false;
                    if (isMatch && action === 'match') correct = true;
                    if (!isMatch && action === 'nomatch') correct = true;
                    
                    const fb = document.getElementById('feedback');
                    if (action === 'timeout') {
                         fb.innerText = "MISS"; fb.className = "feedback incorrect";
                    } else if (correct) {
                        this.score++; fb.innerText = "HIT"; fb.className = "feedback correct";
                    } else {
                        fb.innerText = "ERR"; fb.className = "feedback incorrect";
                    }
                    document.getElementById('score').innerText = this.score;
                    const acc = Math.round((this.score / (i+1)) * 100);
                    document.getElementById('accuracy').innerText = acc + "%";
                }

                // --- PACING ---
                const elapsed = Date.now() - trialStart;
                const targetDur = this.spt * 1000;
                if (elapsed < targetDur) {
                    await new Promise(r => setTimeout(r, targetDur - elapsed));
                }
            }
        } catch (e) {
            console.log("Session end", e);
        } finally {
            this.endSession();
        }
    }

    waitForInput(ms, signal) {
        return new Promise((resolve) => {
            let resolved = false;
            let timerId = null;

            const finish = (val) => {
                if(!resolved) { resolved=true; clearTimeout(timerId); resolve(val); }
            };

            const btnM = document.getElementById('match-btn');
            const btnN = document.getElementById('no-match-btn');
            
            // Re-enable buttons
            btnM.disabled = false; btnN.disabled = false;
            document.querySelector('.response-buttons').style.opacity = '1';

            // Handlers
            const onMatch = (e) => { e.preventDefault(); finish('match'); };
            const onNo = (e) => { e.preventDefault(); finish('nomatch'); };
            
            btnM.onclick = onMatch;
            btnN.onclick = onNo;

            timerId = setTimeout(() => finish('timeout'), ms);
            signal.addEventListener('abort', () => finish('abort'), { once: true });
        });
    }

    endSession() {
        this.running = false;
        document.getElementById('status').innerText = "COMPLETE";
        document.getElementById('start-btn').disabled = false;
        document.getElementById('stop-btn').disabled = true;
        document.getElementById('premise-display').style.opacity = '1';
        document.getElementById('match-btn').disabled = true;
        document.getElementById('no-match-btn').disabled = true;
    }

    stop() { if (this.abortCtrl) this.abortCtrl.abort(); }
}

// --- IPHONE INIT PATTERN ---
const game = new GameEngine();

document.getElementById('start-btn').addEventListener('click', () => {
    // 1. Unlock Audio Context immediately
    window.speechSynthesis.cancel();
    const unlock = new SpeechSynthesisUtterance("Sequence starting.");
    unlock.volume = 1.0;
    window.speechSynthesis.speak(unlock);

    // 2. Config & Run
    game.n = parseInt(document.getElementById('n-slider').value);
    game.k = parseInt(document.getElementById('k-slider').value);
    game.spt = parseFloat(document.getElementById('spt-slider').value);
    const trials = parseInt(document.getElementById('numTrialsInput').value);
    
    game.runSession(trials);
});

document.getElementById('stop-btn').onclick = () => game.stop();

['n', 'k', 'spt'].forEach(id => {
    document.getElementById(`${id}-slider`).oninput = (e) => 
        document.getElementById(`${id}-value`).innerText = e.target.value;
});

</script>
</body>
</html>
